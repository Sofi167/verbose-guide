Вариант 15. Напишите программу для генерации всех путей в лабиринте размером 5×5 
Шаги алгоритма
Шаг 1. Подготовка входных данных
Лабиринт (labyrinth) задаётся как двумерный список (матрица 5 × 5).
Шаг 2. Инициализация функции find_all_paths
Шаг 3. Вспомогательная функция is_valid(x, y)
Шаг 4. Рекурсивная функция backtrack(x, y, path)
Шаги внутри backtrack:
Базовый случай (достигли цели)
Если (x, y) == end, то:
копируем текущий путь path[:] в all_paths;
завершаем рекурсию (return).
Проверка допустимости клетки
Если клетка недопустима (not is_valid(x, y)), завершаем рекурсию.
Отметка клетки как посещённой меняем значение клетки в лабиринте на 2 (чтобы не заходить повторно);добавляем (x, y) в текущий путь path.
Исследование соседей
Перебираем 4 направления (вверх, вниз, влево, вправо) через список [(−1, 0), (1, 0), (0, −1), (0, 1)].
Для каждого направления:вычисляем новые координаты (x + dx, y + dy);вызываем backtrack для новой клетки.
Возврат (backtrack)
После исследования всех соседей:восстанавливаем значение клетки в 0 (снимаем отметку);
Шаг 5. Запуск поиска backtrack(start[0], start[1], [])
Шаг 6. Возврат результата return all_paths
Шаг 7. Вывод результатов paths = find_all_paths(labyrinth)
for i, path in enumerate(paths):
    print(f"Путь {i + 1}: {path}")


Временная сложность O(4^N)
Объяснение: Временная сложность O(4ⁿ) возникает потому, что:
1.	В каждой клетке алгоритм пробует 4 направления (вверх/вниз/влево/вправо).
2.	Максимальная длина пути — n клеток (без повторных посещений).
3.	В худшем случае (без стен) число вариантов растёт как 4 × 4 × … × 4 (n раз), то есть 4ⁿ.
Коротко: 4 варианта на каждом из n шагов → сложность O(4ⁿ).



