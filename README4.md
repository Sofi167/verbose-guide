Вариант 15. Напишите программу для генерации всех путей в лабиринте размером 5×5 
Шаги алгоритма
1.	Представление лабиринта
o	Матрица 5 × 5: grid[5][5].
o	Значения:
	0 — проход,
	1 — стена,
	2 — посещённая клетка (чтобы избежать циклов).
2.	Параметры поиска
o	Начальная точка: (0, 0) (левый верхний угол).
o	Конечная точка: (4, 4) (правый нижний угол).
o	Текущий путь: список координат (x, y).
3.	Рекурсивная функция find_paths(x, y, path)
o	Базовые случаи:
	Если (x, y) — конечная точка: добавить path в список всех путей.
	Если (x, y) вне лабиринта или стена (grid[x][y] == 1): вернуть.
	Если клетка уже посещена (grid[x][y] == 2): вернуть.
o	Действия:
	Отметить клетку как посещённую: grid[x][y] = 2.
	Добавить (x, y) в path.
	Рекурсивно вызвать find_paths для всех соседних клеток (вверх, вниз, влево, вправо).
	После рекурсии: снять отметку (grid[x][y] = 0) и удалить (x, y) из path (возврат).
4.	Запуск поиска
o	Инициализировать all_paths = [].
o	Вызвать find_paths(0, 0, []).
o	Вернуть all_paths.
Временная сложность O(4^N)
Объяснение: Временная сложность O(4ⁿ) возникает потому, что:
1.	В каждой клетке алгоритм пробует 4 направления (вверх/вниз/влево/вправо).
2.	Максимальная длина пути — n клеток (без повторных посещений).
3.	В худшем случае (без стен) число вариантов растёт как 4 × 4 × … × 4 (n раз), то есть 4ⁿ.
Коротко: 4 варианта на каждом из n шагов → сложность O(4ⁿ).



