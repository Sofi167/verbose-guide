Сортировка выбором (Selection Sort) — на каждом шаге алгоритма находят минимальный элемент среди последних и меняют его местами с текущим элементом в массиве.
Анализ алгоритма:
1.	Внешний цикл: Выполняется n раз, где n — количество элементов в массиве.
2.	Внутренний цикл: На каждой итерации внешнего цикла выполняется n - i раз, где i — текущая итерация внешнего цикла.
3.	Общее количество сравнений: Примерно равно n * (n - 1) / 2.
Временная сложность:
o	Лучшая сложность: O(n²) — даже если массив уже отсортирован, алгоритм все равно выполнит все итерации.
o	Средняя сложность: O(n²) — среднее количество операций также пропорционально квадрату размера массива.
o	Худшая сложность: O(n²) — когда массив отсортирован в обратном порядке.


Сортировка обменом (пузырьком) (Bubble Sort) — алгоритм проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Процесс повторяется до тех пор, пока список полностью не отсортируется.
Анализ алгоритма:
1.	Внешний цикл: Выполняется n раз, где n — количество элементов в массиве.
2.	Внутренний цикл: На каждой итерации внешнего цикла выполняется n - i - 1 раз, где i — текущая итерация внешнего цикла.
3.	Общее количество сравнений: Примерно равно n * (n - 1) / 2.
Временная сложность:
o	Лучшая сложность: O(n) — когда массив уже отсортирован, алгоритм может остановиться после первого прохода.
o	Средняя сложность: O(n²) — среднее количество операций также пропорционально квадрату размера массива.
o	Худшая сложность: O(n²) — когда массив отсортирован в обратном порядке.


Сортировка вставками (Insertion Sort) — алгоритм строит отсортированную часть списка, постепенно вставляя каждый элемент на своё место. Он начинает с первого элемента и перемещается вправо, сравнивая каждый элемент с предыдущими элементами и вставляя его на правильное место.
Анализ алгоритма:
1.	Внешний цикл: Выполняется n - 1 раз, где n — количество элементов в массиве.
2.	Внутренний цикл: На каждой итерации внешнего цикла выполняется до i раз, где i — текущая итерация внешнего цикла.
3.	Общее количество сравнений: В худшем случае примерно равно n * (n - 1) / 2.
Временная сложность:
o	Лучшая сложность: O(n) — когда массив уже отсортирован.
o	Средняя сложность: O(n²) — среднее количество операций также пропорционально квадрату размера массива.
o	Худшая сложность: O(n²) — когда массив отсортирован в обратном порядке.


Сортировка слиянием (Merge Sort) — алгоритм состоит в разделении массива пополам, сортировке половин и их слиянии.
Анализ алгоритма:
1.	Разделение массива: Массив разделяется на две половины до тех пор, пока каждая половина не станет размером 1.
2.	Слияние: Отсортированные половины сливаются в один отсортированный массив. Это делается путем сравнения элементов из двух массивов и выбора наименьшего.
Временная сложность:
o	Лучшая сложность: O(n log n) — даже если массив уже отсортирован.
o	Средняя сложность: O(n log n) — среднее количество операций также пропорционально n log n.
o	Худшая сложность: O(n log n) — даже если массив отсортирован в обратном порядке.


Сортировка Шелла (Shellsort) — является модификацией сортировки вставками, сортирует между собой элементы, стоящие на местах, кратных определённому шагу.
Анализ алгоритма:
1.	Выбор шага (gap): Начальный шаг выбирается как половина длины массива, затем он уменьшается вдвое на каждом шаге.
2.	Сортировка вставками с шагом: На каждом шаге сортируем элементы, которые находятся на расстоянии шага друг от друга.
3.	Уменьшение шага: Процесс повторяется до тех пор, пока шаг не станет равным 1.
Временная сложность:
o	Лучшая сложность: O(n log n) — в лучшем случае, когда массив уже отсортирован.
o	Средняя сложность: O(n^(3/2)) — среднее количество операций зависит от выбора шага.
o	Худшая сложность: O(n²) — в худшем случае, когда массив отсортирован в обратном порядке.


Быстрая сортировка (Quick Sort) — один из самых известных и широко используемых алгоритмов сортировки. Алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного (одна — все элементы, меньшие опорного элемента, вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них.
Анализ алгоритма:
1.	Выбор опорного элемента: В данном примере опорный элемент выбирается как последний элемент массива.
2.	Разделение массива: Элементы массива переставляются так, чтобы все элементы, меньшие опорного, оказались слева от него, а все элементы, большие опорного, — справа.
3.	Рекурсия: Процесс повторяется для левого и правого подмассивов до тех пор, пока массив не будет полностью отсортирован.
Временная сложность:
o	Лучшая сложность: O(n log n) — когда массив уже отсортирован или почти отсортирован.
o	Средняя сложность: O(n log n) — среднее количество операций также пропорционально n log n.
o	Худшая сложность: O(n²) — в худшем случае, когда массив отсортирован в обратном порядке и опорный элемент выбирается как первый или последний элемент.


Пирамидальная сортировка — алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка.
Анализ алгоритма:
1.	Построение кучи: Массив преобразуется в двоичную кучу (max-heap), где каждый родительский элемент больше своих дочерних элементов.
2.	Извлечение максимального элемента: Максимальный элемент (корень кучи) перемещается в конец массива.
3.	Повторение процесса: Процесс повторяется для оставшейся части массива до тех пор, пока массив не будет полностью отсортирован.
Временная сложность:
o	Лучшая сложность: O(n log n) — даже если массив уже отсортирован.
o	Средняя сложность: O(n log n) — среднее количество операций также пропорционально n log n.
o	Худшая сложность: O(n log n) — даже если массив отсортирован в обратном порядке.


Последовательный (линейный) поиск — простейший вид поиска заданного элемента на некотором множестве. Осуществляется путём последовательного сравнения очередного рассматриваемого значения с искомым до тех пор, пока эти значения не совпадут. Этот метод является наименее эффективным, так как его временная сложность составляет O(n), где n — количество элементов в списке. Однако он прост в реализации и может быть полезен для небольших списков или в тех случаях, когда данные не отсортированы.
Анализ алгоритма:
1.	Проход по массиву: Алгоритм последовательно проверяет каждый элемент массива.
2.	Сравнение: Каждый элемент сравнивается с искомым значением.
3.	Возврат результата: Если элемент найден, возвращается его индекс. Если элемент не найден, возвращается -1.
Временная сложность:
o	Лучшая сложность: O(1) — если искомый элемент находится в начале массива.
o	Средняя сложность: O(n) — в среднем случае, когда элемент находится в середине массива.
o	Худшая сложность: O(n) — если искомый элемент находится в конце массива или его нет в массиве.


Бинарный (двоичный, дихотомический) поиск — это поиск заданного элемента на упорядоченном множестве, осуществляемый путём неоднократного деления этого множества на две части таким образом, что искомый элемент попадает в одну из этих частей. Поиск заканчивается при совпадении искомого элемента с элементом, который является границей между частями множества или при отсутствии искомого элемента. Преимуществом бинарного поиска является более низкая трудоёмкость по сравнению с последовательным поиском. Недостаток заключается в том, что он применим только на отсортированных множествах.
Анализ алгоритма:
1.	Поиск по половине: На каждом шаге алгоритм уменьшает размер массива для поиска вдвое.
2.	Сравнение: Средний элемент сравнивается с искомым значением.
3.	Возврат результата: Если элемент найден, возвращается его индекс. Если элемент не найден, возвращается -1.
Временная сложность:
o	Лучшая сложность: O(1) — если искомый элемент находится в середине массива.
o	Средняя сложность: O(log n) — среднее количество операций также пропорционально log n.
o	Худшая сложность: O(log n) — даже если элемент находится в конце массива или его нет в массиве.


Интерполирующий поиск — это алгоритм поиска для отсортированных наборов данных, таких как массивы или списки. Он предсказывает позицию нужного элемента на основе разницы значений. Эффективен, если элементы распределены достаточно равномерно.
Анализ алгоритма:
1.	Поиск по половине: На каждом шаге алгоритм уменьшает размер массива для поиска, используя линейную интерполяцию.
2.	Сравнение: Элемент в предполагаемой позиции сравнивается с искомым значением.
3.	Возврат результата: Если элемент найден, возвращается его индекс. Если элемент не найден, возвращается -1.
Временная сложность:
o	Лучшая сложность: O(1) — если искомый элемент находится в середине массива.
o	Средняя сложность: O(log log n) — среднее количество операций также пропорционально log log n.
o	Худшая сложность: O(n) — в худшем случае, когда массив имеет равномерное распределение и искомый элемент находится в конце массива.


Поиск по Фибоначчи — это эффективный алгоритм поиска, используемый для нахождения целевого значения в отсортированной коллекции, такой как массив или список. По принципу он аналогичен бинарному поиску, но использует числа Фибоначчи для определения позиций для сравнения.
Анализ алгоритма:
1.	Поиск по половине: На каждом шаге алгоритм уменьшает размер массива для поиска, используя числа Фибоначчи.
2.	Сравнение: Элемент в вычисленном индексе сравнивается с искомым значением.
3.	Возврат результата: Если элемент найден, возвращается его индекс. Если элемент не найден, возвращается -1.
Временная сложность:
o	Лучшая сложность: O(1) — если искомый элемент находится в середине массива.
o	Средняя сложность: O(log n) — среднее количество операций также пропорционально log n.

o	Худшая сложность: O(log n) — в худшем случае, когда массив имеет равномерное распределение и искомый элемент находится в конце массива.
