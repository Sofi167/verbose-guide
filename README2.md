Сортировка выбором (Selection Sort) — на каждом шаге алгоритма находят минимальный элемент среди последних и меняют его местами с текущим элементом в массиве.
Анализ алгоритма:
1.	Внешний цикл: Выполняется n раз, где n — количество элементов в массиве.
2.	Внутренний цикл: На каждой итерации внешнего цикла выполняется n - i раз, где i — текущая итерация внешнего цикла.
3.	Общее количество сравнений: Примерно равно n * (n - 1) / 2.
Анализ кода:
Внешний цикл (for i in range(n)):Внешний цикл пробегает по каждому элементу массива. На каждой итерации внешний цикл выбирает первую позицию следующей неотсортированной части массива.
Внутренний цикл (for j in range(i+1, n)):Во внутреннем цикле мы ищем минимальный элемент в неотсортированной части массива, начинающейся с позиции i+1. Переменная min_index отслеживает индекс минимального элемента.
Замена элементов:После завершения внутреннего цикла меняется местами первый элемент неотсортированной части (arr[i]) с найденным минимальным элементом (arr[min_index]).
Завершение:Процесс продолжается до тех пор, пока весь массив не будет отсортирован.
Сложность: O(N^2) во всех случаях, так как используются два вложенных цикла: внешний проходит по всем элементам, а внутренний ищет минимум среди оставшихся.

Сортировка обменом (пузырьком) (Bubble Sort) — алгоритм проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Процесс повторяется до тех пор, пока список полностью не отсортируется.
Анализ алгоритма:
1.	Внешний цикл: Выполняется n раз, где n — количество элементов в массиве.
2.	Внутренний цикл: На каждой итерации внешнего цикла выполняется n - i - 1 раз, где i — текущая итерация внешнего цикла.
3.	Общее количество сравнений: Примерно равно n * (n - 1) / 2.
Анализ кода: 
Функция bubbleSort:Получает массив и его длину, сортируя элементы методом пузырька.
Внешний цикл:Контролирует количество проходов, исключая уже отсортированные элементы.
Внутренний цикл:Прямо сравнивает соседние элементы и меняет их местами, если нарушен порядок.
Оптимизация:Если за проход не было перестановок, прекращает работу досрочно.
Работа:На каждом проходе массив частично упорядочивается, сдвигая больший элемент вправо.
Свойства:Простота реализации, низкая эффективность O(n^2), стабильная работа с дополнительной памятью O(1).
Временная сложность:O(N^2). Пузырьковая сортировка удобна для маленьких массивов и учебного материала, но крайне неэффективна для больших данных из-за квадратичной сложности.


Сортировка вставками (Insertion Sort) — алгоритм строит отсортированную часть списка, постепенно вставляя каждый элемент на своё место. Он начинает с первого элемента и перемещается вправо, сравнивая каждый элемент с предыдущими элементами и вставляя его на правильное место.
Анализ алгоритма:
1.	Внешний цикл: Выполняется n - 1 раз, где n — количество элементов в массиве.
2.	Внутренний цикл: На каждой итерации внешнего цикла выполняется до i раз, где i — текущая итерация внешнего цикла.
3.	Общее количество сравнений: В худшем случае примерно равно n * (n - 1) / 2.
Анализ кода:
Функция insertionSort:• Получает массив arr и его длину n.• Внешний цикл for (int i = 1; i < n; i++) проходит по массиву от второго элемента.
Выбор ключа и вставка:• Берётся текущий элемент key = arr[i].• Вложенный цикл while (j >= 0 && arr[j] > key) сдвигает большие элементы вправо, освобождая место для вставки.
Вставка ключа:• После сдвига нужных элементов, ключ вставляется на освободившееся место: arr[j + 1] = key.
Пример работы:Масштабируется с левого края, постепенно встраивая элементы на нужные позиции.
Особенности:Простая реализация, устойчивая к небольшим изменениям порядка, эффективна для маломерных массивов.
Временная сложность: Сортировка вставками работает медленно на больших наборах данных. Её скорость обычно оценивают как **среднюю и худшую** — $O(n^2)$, а в наилучших условиях, когда массив уже отсортирован, её быстродействие повышается до $O(n)$.



Сортировка слиянием (Merge Sort) — алгоритм состоит в разделении массива пополам, сортировке половин и их слиянии.
Анализ алгоритма:
1.	Разделение массива: Массив разделяется на две половины до тех пор, пока каждая половина не станет размером 1.
2.	Слияние: Отсортированные половины сливаются в один отсортированный массив. Это делается путем сравнения элементов из двух массивов и выбора наименьшего.
Анализ кода:
Функция mergeSort:
Разделяет массив на две части.
Рекурсивно сортирует каждую половину.
Сливает отсортированные половины.
Функция merge:  
Сливает две отсортированные части массива в единую отсортированную последовательность.
Методы копирования:  
Используются стандартные средства Java (System.arraycopy) для быстрого копирования элементов.
Временная сложность:
Сортировка слиянием всегда работает за время пропорциональное произведению размера массива на логарифм его размера, то есть примерно O(n⋅logn). Независимо от того, какой порядок элементов в исходном массиве, сортировка слиянием стабильно и предсказуемо справляется с задачей за примерно одинаковое время.


Сортировка Шелла (Shellsort) — является модификацией сортировки вставками, сортирует между собой элементы, стоящие на местах, кратных определённому шагу.
Анализ алгоритма:
1.	Выбор шага (gap): Начальный шаг выбирается как половина длины массива, затем он уменьшается вдвое на каждом шаге.
2.	Сортировка вставками с шагом: На каждом шаге сортируем элементы, которые находятся на расстоянии шага друг от друга.
3.	Уменьшение шага: Процесс повторяется до тех пор, пока шаг не станет равным 1.
Анализ кода:
Функция shellSort:Реализует алгоритм сортировки Шелла, уменьшая шаг (gap) и производя вставочную сортировку с определенным шагом.
Выбор шага:Первоначально шаг равен половине длины массива, далее уменьшается в два раза на каждой итерации.
Внутренний цикл:Сортирует элементы, находящиеся на расстоянии gap, переставляя их на подходящие позиции.
Масштабируемость:Сортировка Шелла эффективна для больших массивов, так как позволяет уменьшить количество необходимых сравнений и перемещений.
Временная сложность:
Сортировка Шелла работает за время примерно O(n ^1.25 )—O(n^1.5) , иногда достигает лучшей скорости, приближенной к O(n * log n), в зависимости от последовательности используемых расстояний (интервалов). Её реальная производительность варьируется, но в среднем заметно превосходит стандартные методы типа сортировки вставками или пузырьковой сортировки.


Быстрая сортировка (Quick Sort) — один из самых известных и широко используемых алгоритмов сортировки. Алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного (одна — все элементы, меньшие опорного элемента, вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них.
Анализ алгоритма:
1.	Выбор опорного элемента: В данном примере опорный элемент выбирается как последний элемент массива.
2.	Разделение массива: Элементы массива переставляются так, чтобы все элементы, меньшие опорного, оказались слева от него, а все элементы, большие опорного, — справа.
3.	Рекурсия: Процесс повторяется для левого и правого подмассивов до тех пор, пока массив не будет полностью отсортирован.
Анализ кода:
Функция swap:Обеспечивает обмен двух элементов массива.
Функция partition:Разделяет массив на две части относительно опорного элемента (pivot), который выбирается последним элементом. Все элементы меньше или равные опорному отправляются влево, больше — вправо.
Функция quickSort:Рекурсивно сортирует обе части массива, вызывая себя дважды: для элементов левее и правее опорного.
Функция printArray:Выводит массив на экран.
Рабочий процесс:Быстро сортирует массив, разделяя его на две части и рекурсивно повторяя операцию, пока весь массив не будет отсортирован.
Временная сложность:
Быстрая сортировка работает в среднем за время O(nlogn), n — количество элементов. В худшем случае, если выбор опорного элемента неудачен, сложность возрастает до O(n^2). Однако на практике вероятность возникновения худшего сценария мала, поэтому быстрая сортировка весьма эффективна и широко используется.


Пирамидальная сортировка — алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка.
Анализ алгоритма:
1.	Построение кучи: Массив преобразуется в двоичную кучу (max-heap), где каждый родительский элемент больше своих дочерних элементов.
2.	Извлечение максимального элемента: Максимальный элемент (корень кучи) перемещается в конец массива.
3.	Повторение процесса: Процесс повторяется для оставшейся части массива до тех пор, пока массив не будет полностью отсортирован.
Анализ кода:
Функция heapify:Поддерживает свойство кучности (Max Heap), где родительские узлы больше детей. Восстанавливает структуру кучи, начиная с узла i.
Функция heapSort:• Строит Max Heap из исходного массива.• Удаляет максимальный элемент (корень) и восстанавливает кучу, повторяя процесс, пока массив не будет отсортирован.
Функция printArray:Выводит массив на экран.
Метод main:Демонстрирует работу сортировки на примере массива.
Временная сложность:
Пирамидальная сортировка всегда работает за время O(n*logn), независимо от исходного порядка элементов. Это связано с особенностями пирамидальной структуры данных (кучи), позволяющей поддерживать постоянный уровень эффективности.


Последовательный (линейный) поиск — простейший вид поиска заданного элемента на некотором множестве. Осуществляется путём последовательного сравнения очередного рассматриваемого значения с искомым до тех пор, пока эти значения не совпадут. Этот метод является наименее эффективным, так как его временная сложность составляет O(n), где n — количество элементов в списке. Однако он прост в реализации и может быть полезен для небольших списков или в тех случаях, когда данные не отсортированы.
Анализ алгоритма:
1.	Проход по массиву: Алгоритм последовательно проверяет каждый элемент массива.
2.	Сравнение: Каждый элемент сравнивается с искомым значением.
3.	Возврат результата: Если элемент найден, возвращается его индекс. Если элемент не найден, возвращается -1.
Временная сложность:
Линейный поиск выполняется за время O(n), n — количество элементов в списке. 


Бинарный (двоичный, дихотомический) поиск — это поиск заданного элемента на упорядоченном множестве, осуществляемый путём неоднократного деления этого множества на две части таким образом, что искомый элемент попадает в одну из этих частей. Поиск заканчивается при совпадении искомого элемента с элементом, который является границей между частями множества или при отсутствии искомого элемента. Преимуществом бинарного поиска является более низкая трудоёмкость по сравнению с последовательным поиском. Недостаток заключается в том, что он применим только на отсортированных множествах.
Анализ алгоритма:
1.	Поиск по половине: На каждом шаге алгоритм уменьшает размер массива для поиска вдвое.
2.	Сравнение: Средний элемент сравнивается с искомым значением.
3.	Возврат результата: Если элемент найден, возвращается его индекс. Если элемент не найден, возвращается -1.
Временная сложность:
Бинарный поиск выполняется за время O(logn), где n — количество элементов в отсортированном массиве. Такое поведение связано с тем, что на каждом шаге область поиска сокращается вдвое, что позволяет находить элемент значительно быстрее, чем при полном просмотре массива.


Интерполирующий поиск — это алгоритм поиска для отсортированных наборов данных, таких как массивы или списки. Он предсказывает позицию нужного элемента на основе разницы значений. Эффективен, если элементы распределены достаточно равномерно.
Анализ алгоритма:
1.	Поиск по половине: На каждом шаге алгоритм уменьшает размер массива для поиска, используя линейную интерполяцию.
2.	Сравнение: Элемент в предполагаемой позиции сравнивается с искомым значением.
3.	Возврат результата: Если элемент найден, возвращается его индекс. Если элемент не найден, возвращается -1.
Временная сложность:
Интерполирующий поиск работает за время примерно O(loglogn) в среднем случае, где n — количество элементов в отсортированном массиве. Такая высокая эффективность возможна благодаря тому, что алгоритм точнее определяет положение искомого элемента, учитывая разницу между ключами, а не просто делит массив пополам, как в бинарном поиске. Однако в худшем случае, когда данные неравномерно распределены, его сложность может ухудшиться до O(n).

Поиск по Фибоначчи — это эффективный алгоритм поиска, используемый для нахождения целевого значения в отсортированной коллекции, такой как массив или список. По принципу он аналогичен бинарному поиску, но использует числа Фибоначчи для определения позиций для сравнения.
Анализ алгоритма:
1.	Поиск по половине: На каждом шаге алгоритм уменьшает размер массива для поиска, используя числа Фибоначчи.
2.	Сравнение: Элемент в вычисленном индексе сравнивается с искомым значением.
3.	Возврат результата: Если элемент найден, возвращается его индекс. Если элемент не найден, возвращается -1.
Временная сложность:
Поиск по Фибоначчи выполняется за время O(logn), где n — количество элементов в отсортированном массиве. Подобно бинарному поиску, на каждом шаге область поиска сокращается, но разделение массива основано на числах Фибоначчи, что обеспечивает эффективную скорость поиска, сравнимую с бинарным поиском.
